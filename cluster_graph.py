import math

import networkx
import networkx as nx
import osmnx as ox

import city_graphs


class ClusterGraph:
    """
    ClusterGraph clusters a spatial NetworkX graph (from OSMnx) into
    clusters based on geographic proximity (radius-based, non-transitive), and builds a cluster-level graph with hyperedges.

    Each cluster is centered on a seed node, and includes only those nodes whose distance to the seed is <= threshold.

    Parameters
    ----------
    G : networkx.Graph
        A graph generated by OSMnx (nodes in lat/lng CRS).
    threshold : float
        Distance threshold in meters for clustering (default is 2000 m).

    Attributes
    ----------
    G_proj : networkx.Graph
        The input graph projected to a metric CRS (e.g., UTM).
    pos : dict
        Mapping of node -> (x, y) in projected CRS.
    node_to_cluster : dict
        Mapping of each original node to its cluster ID.
    clusters : dict
        Mapping of cluster ID -> set of original node IDs in that cluster.
    cluster_graph : networkx.Graph
        The resulting cluster-level graph.
    hyperedges : dict
        Mapping of frozenset({cluster_u, cluster_v}) -> list of original edges (u, v) connecting those clusters.
    """
    def __init__(self, G: nx.Graph, threshold: float = 2000.0):
        # Project to a metric CRS (units in meters)
        self.G_proj = ox.project_graph(G)
        self.threshold = threshold
        # Extract node positions in projected CRS
        self.pos = {node: (data['x'], data['y'])
                    for node, data in self.G_proj.nodes(data=True)}
        # Placeholders
        self.node_to_cluster = {}
        self.clusters = {}
        self.cluster_graph = None
        self.hyperedges = {}
        self.cluster()

    def cluster(self) -> nx.Graph:
        """
        Perform radius-based clustering: each cluster is a ball of radius threshold around a seed node.
        """
        # Prepare unassigned nodes set
        unassigned = set(self.pos.keys())
        comps = []

        # Greedy clustering by seed
        # Sort for deterministic behavior
        for seed in sorted(unassigned):
            if seed not in unassigned:
                continue
            sx, sy = self.pos[seed]
            # Nodes within threshold of the seed
            comp = {n for n in unassigned
                    if math.hypot(self.pos[n][0] - sx, self.pos[n][1] - sy) <= self.threshold}
            # Assign cluster
            cid = len(comps)
            for n in comp:
                self.node_to_cluster[n] = cid
            comps.append(comp)
            # Remove from unassigned
            unassigned -= comp

        # Store clusters dict mapping ID -> nodes
        self.clusters = {cid: comp for cid, comp in enumerate(comps)}

        # Build cluster-level graph
        C = nx.Graph()
        for cid, comp in enumerate(comps):
            xs = [self.pos[n][0] for n in comp]
            ys = [self.pos[n][1] for n in comp]
            centroid = (sum(xs) / len(xs), sum(ys) / len(ys))
            C.add_node(cid, members=list(comp), centroid=centroid)

        # Build hyperedges dict and weighted edges between clusters
        for u, v in self.G_proj.edges():
            cu = self.node_to_cluster.get(u)
            cv = self.node_to_cluster.get(v)
            if cu is None or cv is None or cu == cv:
                continue
            key = frozenset((cu, cv))
            self.hyperedges.setdefault(key, []).append((u, v))
            if C.has_edge(cu, cv):
                C[cu][cv]['weight'] += 1
            else:
                C.add_edge(cu, cv, weight=1)

        self.cluster_graph = C
        return C

    def get_cluster_graph(self) -> nx.Graph:
        """
        Return the cluster-level graph, clustering if not already done.
        """
        if self.cluster_graph is None:
            return self.cluster()
        return self.cluster_graph

    def get_clusters(self) -> dict:
        """
        Return the dict mapping cluster ID to set of node IDs.

        Returns
        -------
        clusters : dict
            keys are cluster IDs, values are sets of original node IDs.
        """
        if not self.clusters:
            self.cluster()
        return self.clusters

    def get_hyperedges(self) -> dict:
        """
        Return the dict of hyperedges between clusters:
        keys are frozensets of cluster IDs, values are lists of original edges (u, v).
        """
        if not self.hyperedges:
            self.cluster()
        return self.hyperedges


if __name__ == "__main__":
    G = city_graphs.graph_from_file("Banja Luka")
    print("Graph obtained, ",G)
    cg = ClusterGraph(G, threshold=1000)
    print("Cluster graph obtained, ",cg)
    from random import choice
    print(networkx.dijkstra_path(cg.get_cluster_graph(),choice(list(cg.get_cluster_graph().nodes())),choice(list(cg.get_cluster_graph().nodes())),"weight"))